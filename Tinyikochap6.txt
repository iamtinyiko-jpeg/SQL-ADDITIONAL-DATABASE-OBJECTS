CHAPTER 6

/*To perform the following assignments, refer to the tables in the JustLee Books database.
1. Create a sequence for populating the Customer# column of the CUSTOMERS table. When
setting the start and increment values, keep in mind that data already exists in this table
The options should be set to not cycle the values and not cache any values, and no
minimum or maximum values should be declared.
2. Add a new customer row by using the sequence created in Question 1. The only data
currently available for the customer is as follows: last name = Shoulders, first name =
Frank, and zip = 23567.
3. Create a sequence that generates integers starting with the value 5. Each value should be
three less than the previous value generated. The lowest possible value should be 0, and
the sequence shouldn’t be allowed to cycle. Name the sequence MY_FIRST_SEQ.
4. Issue a SELECT statement that displays NEXTVAL for MY_FIRST_SEQ three times.
Because the value isn’t being placed in a table, use the DUAL table in the FROM clause of
the SELECT statement. What causes the error on the third SELECT?
5. Change the setting of MY_FIRST_SEQ so that the minimum value that can be generated is–1000.
6. A new table has been requested to support tracking automated emails sent to customers.
Create the table and add data as described below.
Tablename: email_log
Columns: emailid (numeric), emaildate (datetime), customer# (numeric)
Primary key: emailid column, define as an Identity Column
Add the following data rows and display resulting rows (if any errors occur, explain
why the error is expected)
1. Emaildate ¼ current date, customer# ¼ 1007
2. Emailid ¼ specify to use the column default value, emaildate ¼ current date,
customer# ¼ 1008
3. Emailid ¼ 25, emaildate ¼ current date, customer# ¼ 1009
7. Create a private synonym that enables you to reference the MY_FIRST_SEQ object as
NUMGEN.
8. Use a SELECT statement to view the CURRVAL of NUMGEN. Delete the NUMGEN
synonym and MY_FIRST_SEQ.
9. Create a bitmap index on the CUSTOMERS table to speed up queries that search for
customers based on their state of residence. Verify that the index exists, and then delete
the index.
10. Create a B-tree index on the customer’s Lastname column. Verify that the index exists by
querying the data dictionary. Remove the index from the database.
11. Many queries search by the number of days to ship (number of days between the order
and shipping dates). Create an index that might improve the performance of these queries.*/



1.SELECT MAX(Customer#) FROM CUSTOMERS;
CREATE SEQUENCE CUSTOMER_SEQ
START WITH 1021
INCREMENT BY 1
NOCYCLE;

2.INSERT INTO CUSTOMERS (CUSTOMER#, LASTNAME, FIRSTNAME, ZIP)
VALUES (CUSTOMER_SEQ.NEXTVAL, 'SHOULDERS', 'FRANK', 23567);

3.CREATE SEQUENCE MY_FIRST_SEQ
START WITH 5               
INCREMENT BY -3           
MINVALUE 0                
MAXVALUE 5                 
NOCYCLE;   

4.SELECT MY_FIRST_SEQ.NEXTVAL FROM DUAL;
SELECT MY_FIRST_SEQ.NEXTVAL FROM DUAL;
SELECT MY_FIRST_SEQ.NEXTVAL FROM DUAL;

5.ALTER SEQUENCE MY_FIRST_SEQ
MINVALUE -1000;

6.CREATE TABLE EMAIL_LOG (
EMAILID NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
EMAILDATE DATE DEFAULT SYSDATE,
CUSTOMER# NUMBER NOT NULL);
INSERT INTO EMAIL_LOG (EMAILDATE, CUSTOMER#) VALUES (SYSDATE, 1007);
INSERT INTO EMAIL_LOG (EMAILDATE, CUSTOMER#) VALUES (SYSDATE, 1008);
INSERT INTO EMAIL_LOG (EMAILID, EMAILDATE, CUSTOMER#) VALUES (25, SYSDATE, 1009);
CANNOT INSERT INTO A GENERATED IDENTITY COLUMN

7.CREATE SYNONYM NUMGEN FOR MY_FIRST_SEQ;

8.SELECT NUM.CURRVAL FROM DUAL;
SEQUENCE DOES NOT EXIST

9.DROP SYNONYM NUMGEN;
DROP SEQUENCE MY_FIRST_SEQ;


10.CREATE BITMAP INDEX IDX_STATE ON CUSTOMERS (STATE);
SELECT INDEX_NAME, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME = 'CUSTOMERS';
DROP INDEX IDX_STATE;
CREATE INDEX IDX_LASTNAME ON CUSTOMERS (LASTNAME);
SELECT INDEX_NAME, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME = 'CUSTOMERS';
DROP INDEX IDX_LASTNAME;


11.CREATE INDEX IDX_DAYS_TO_SHIP 
ON ORDERS (SHIPDATE - ORDERDATE);
SELECT INDEX_NAME, TABLE_NAME FROM USER_INDEXES WHERE TABLE_NAME = 'ORDERS';